\section{Galimi kodo skirstymo į paketus šablonai}
Diskusijose, kaip reikėtų skirstyti programinį kodą, paprastai akcentuojami du metodai - pagal \textit{techninį sluoksnį},
kur kiekvienam funkcionalumui arba kompiuterinės sistemos sluoksniui yra sukuriamas paketas,
grupuojant skirtingų dalykinių sričių esybes, arba pagal \textit{dalykinės srities esybes}, kur vienos esybės kodas, dalykinės srities
esybės funkcionalumas skirtingose programiniuose sluoksniuose yra patalpintas viename pakete~\cite{PackagingWays}
Tačiau šie du metodai yra gan platūs ir, dažniausiai jų nėra griežtai laikomasi - klasės būna išskaidytos remiantis papildomomis taisyklėmis,
siekiant išspresti sistemos planavimo metu kylančias problemas. Norint išskirti šiuos šablonus, buvo nagrinėjamos atviro kodo sistemos,
stebimi nukrypimai nuo numatytojo skirstymo metodo bei ieškoma paaiškinimų, kodėl šie sprendimai buvo priimti.
Nuspręsti, kaip žmonės supranta programinį kodą yra gan sudėtingas ir subjektyvus procesas, todėl aprašant šablonus kodo skirstymui
geriau akcentuoti, kaip sugrupuoti paketai bendrauja tarpusavyje ir skirstyti juos pagal klasių naudojimo atvejus ir priklausomybes.
Taip kodo grupavimo metodai yra labiau artimi Martino aprašytiems principams.

\subsection{Pagal komponentą}
Organizavimas pagal komponentus sumažina sistemos sudėtingumą, pabrėždamas išorinę ir vidinę kodo vienetų darną.
Išorinė darna reiškia, kad paketas turi minimalią sąsają \angl{interface}, kuri atskleidžia tik konceptus (metodus arba duomenų tipus),
kurie yra glaudžiai susiję su komponento teikiama paslauga.
Vidinė darna reiškia, kad pakuotėje esantis kodas yra stipriai susijęs tarpusavyje ir susijęs su teikiama paslauga.

Kodas yra grupuojamas į mažus paketus, turinčius vieną, aiškiai apibrėžtą funkcionalumą ar tikslą, aprašant abstrakciją, kokie paketo elementai
yra pasiekiami iš išorės ir kaip jie naudojami.
Taip sukuriamas kodas, kuris yra lengviau suprantamas.
Tokią kodo grupavimo tvarką sunku palaikyti, tačiau jos rezultatas - kodas, kuris yra lengviau suprantamas, lengviau pagerinamas, lengviau testuojamas
ir, dėl aiškiai aprašytų sąsajų, lengviau pernaudojamas.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.2]{img/component_packaging}
    \caption{Sistemos sugrupuotos pagal komponentą pavyzdys}
    \label{img:component_packaging}
\end{figure}

\subsection{Problemos}
Norint išskirti galimus šablonus paketams skirstyti, reikėtų
analizuoti jų panaudojimą atviro kodo sistemose, siekant pastebėti, kur buvo nukrypta nuo bendresnio kodo skirstymo
būdo ir identifikuoti klausimus arba problemas, kurias buvo bandoma išspresti.


\subsubsection{Pagalbinių, daugkartinio naudojimo klasių skirstymas}
Pagalbinės ir daugkartinio naudojimo klasės dažniausiai negali būti patogiai grupuojamos skirstant pagal domeno esybes - pagalbines klases gali
naudoti kelios esybės, todėl neaišku, prie kurios jas reikėtų priskirti. Skirstant pagal techninį sluoksnį, bazines pagalbines klases gali naudoti keli
sluoksniai.
Didžiausia problema, susijusi su pagalbinėmis klasėmis, kurios turėtų išspręsti dažnai sistemoje sutinkamas problemas -
inžinieriai, dirbantys prie sistemos nežino apie jų egzistavimą, todėl jų nenaudoja,
tai veda prie didesnio kodo pasikartojimo arba kelių skirtingų to paties pagalbinio funkcionalumo įgyvendinimo.

\begin{figure}[H]
\snugshade
\dirtree{%
    .1 {/} .
    .2 {users} .
    .3 {UserRolesGrouping} .
    .3 {ArrayGroupingHelper} .
    .2 {\ldots} .
    .2 {payments} .
    .3 {PaymentScheduler} .
    .2 {\ldots} .
    .2 {transactions} .
    .3 {TransactionBatching} .
    .3 {utils} .
    .4 {ArrayGroupByUtil} .
}
\endsnugshade
\caption{Sistemos pavyzdys, kur labai panašią funkciją atliekančios klasės \textit{ArrayGroupByUtil} ir \textit{ArrayGroupingHelper}
egzistuoja todėl, kad inžinierius nerado jau įgyvendintos klasės, dėl aiškios struktūros daugartinio
panaudojimo klasėms trūkumo.}
\end{figure}
Vienas iš šablonų, sprendžiančių šią problemą, galėtų būti turėti vieną paketą, skirtą visoms pagalbinėmis klasėmis, kuris yra paminėtas sistemos
dokumentacijoje ir apie jo egzistavimą teoriškai žino visi komandos nariai.
Pakete reikėtų turėti atskiras klases kiekvienam bendriniam domenui, iš kurios pavadinimo programuotojas galėtų nuspresti,
kad jo ieškomas funkcionalumas, bus būtent toje klasėje.

\begin{figure}[H]
\snugshade
\dirtree{%
    .1 {/} .
    .2 {users} .
    .3 {UserRolesGrouping} .
    .2 {\ldots} .
    .2 {payments} .
    .3 {PaymentScheduler} .
    .2 {\ldots} .
    .2 {transactions} .
    .3 {TransactionBatching} .
    .2 {common} .
    .3 {Arrays} .
    .3 {Maps} .
    .3 {SqlQueries} .
    .3 {Users} .
}
\endsnugshade
\caption{Sistemos pavyzdys, kur visas bendrinio panaudojimo kodas guli \textit{common} pakete, pirmame sistemos paketų lygyje, todėl
pagalbinės klasės yra lengvai randamos.}
\end{figure}

Jei pagalbinių klasių dydis labai išauga, jas galima sumažinti ir vietoj vienos atskiros klasės vienai bendrinei sričiai, sukurti vieną paketą,
ir jame turėti kelias pagalbines klases, susijusias su tuo domenu.
Tokiu atveju reikia užtikrinti, kad iš klasių pavadinimo aišku, kokį srities subdomeną padengia klasė.
Tokį pagalbinių klasių skirstymo metodą naudoja keletas repozitorijų - pavyzdžiui, užrašinės aplikacijos  \footnote{\url{https://github.com/federicoiosue/Omni-Notes/tree/develop/omniNotes/src/main/java/it/feio/android/omninotes/utils}} bei
\footnote{\url{https://github.com/hackjutsu/Fire_Sticker/tree/master/app/src/main/java/com/gogocosmo/cosmoqiu/fire_sticker/Utils}}

\begin{figure}[H]
\snugshade
\dirtree{%
    .1 {/common} .
    .2 {arrays} .
    .3 {ArrayFilters} .
    .3 {ArrayComparators} .
    .2 {\ldots} .
    .2 {maps} .
    .3 {MapTransformations} .
    .3 {MapJoining} .
    .2 {json} .
    .3 {JsonParser} .
    .2 {\ldots} .
    .2 {database} .
    .3 {DatabaseConnection} .
    .3 {DatabaseQueries} .
}
\endsnugshade
\caption{Sistemos pavyzdys, kur bendrinio panaudojimo kodas guli \textit{common} pakete, po domeno subpaketais, taip sumažinant klasių dydį }
\end{figure}

Naudojant tokį šabloną, programuotojas, susiduriantis su bendrine problema, kuri, labai tikėtina, jau yra išspresta sistemoje turėtų
aiškų procesą, kaip elgtis šioje situacijoje:
\begin{enumerate}
    \item Atsidaryti vieną paketą, skirtą bendrinio panaudojimo kodui
    \item Pakete surasti klasę, kurios pavadinimas būtų susijęs su jo problema
    \item Klasės funkcijų saraše surasti jam tinkamą funkciją.
    \item Jei reikalingas funkcionalumas nerastas, įgyvendinti jį pasirinktoje klasėje, padengti jį testais,
    bei aprašyti dokumentaciją, kaip funkcija turėtų būti naudojama.
    \item Iškviesti rastą arba sukurtą funkciją iš bendrinio panaudojimo kodo paketo savo funkcionalume
\end{enumerate}

\subsubsection{Ka daryti esant dideliam priklausomybių nuo paketo skaičiui?}
Didelis priklausomybių nuo specifinio paketo skaičius (arba aferentinės jungtys), reiškia, kad pokyčiai tame pakete turės įtaką kelioms klasėms.
Jei tokia tendencija yra būdinga visai sistemai, sistema tampa mažiau lanksti pokyčiams, kadangi net ir paprastas pakeitimas
daro įtaką reišmingai sistemos daliai, pokyčiai yra labiau linkę keisti bendrą sistemos architektūrą.
Taip pat naujos sistemos versijos išleidimo \angl{release} procesas tampa sudetingesnis, kadangi yra paveikiama daugiau klasių.

Robert C. Martin bendro sąryšio principas, kuris teigia, kad visos tarpusavyje susijusios klasės turėtų būti vienam pakete,
akcentuoja siekiamybę turėti gan mažus paketus, turinčius aiškiai apibrėžtą funkcionalumą, priežastį egzistuoti, taip užtikrinant
glaudų tarpusavyje susijusių klasių saryšį.
Šis principas galėtų būti kodo skirstymo šablonas, užtikrinantis racionalų aferentinių jungčių skaičių paketuose.
Vadovaujantis šiuo šablonu kiekvieną paketą reikėtų realizuoti kaip komponentą, teikiantį vieną funkcionalumą,
turintį minimalią sąsają \angl{interface}, kuri atskleidžia tik konceptus (metodus arba duomenų tipus),
kurie yra glaudžiai susiję su komponento teikiama paslauga.

Paketas turintis vieną funkciją yra naudojamas tik tų paketų, kuriems reikia būtent tos funkcijos,
taip užtikrinant tik mažos sistemos dalies priklausomybę nuo vieno paketo.

Taip pat mažas paketo funkcionalumas reiškia, kad minėtas paketas skirtas funkcionalumui įgyvendinti naudos minimalų kitų sistemos esybių skaičių,
taip sumažinant ir eferentinių jungčių skaičių.

Toks skirstymo būdas

Žemiau esančiuose paveikslėliuose galima matyti, kaip išskaidant paketus, turinčius kelis funckionalumus, yra sumažinamas paketų
priklausomybių skaičius.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.15]{img/excesive_deps}
    \caption{Sistemos pavyzdys su kelias funkcijas atliekančiais paketais}
    \label{img:excesive_deps}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.13]{img/good_deps}
    \caption{Sistemos pavyzdys su aiškią, vieną funkciją turinčiais paketais}
    \label{img:good_deps}
\end{figure}

\subsubsection{Ka daryti su daug skirtingų sąsajų implementacijų?}
Sistemai plečiantis, galima susidurti su problema, kad išauga sąsajos implementacijų skaičius. Ši problema gali iškilti
tiek bandant skirstyti kodą pagal domeno esybes, tiek pagal techninį sluoksnį. Skirstant pagal domeną, gali būti neaišku, kur turėtų
būti sukuriamas naujas esybės paketa. Skirstant kodą pagal techninį sluoksnį, gali susidaryti klasių perteklius, pavyzdžiui,
model pakete. Tokiu atveju navigacija pakete pasidaro sudėtinga, neaišku, kas implementuoja. Šią problemą būtų galima spręsti sukuriant
sub paketus kiekvienos sąsajos implementacijoms. Taip pat, jei vienos sąsajos implementacijai reikalingos kelios klasės, jas galima
išskirti į atskirą paketą.

\subsubsection{Ka daryti su mikroservisų architektūra?}
\subsubsection{Ka daryti su paslėptom priklausomybėm?}
\subsubsection{Kaip grupuoti kodą mono repozitorijoj?}
\subsubsection{Ka daryti su greitai besikeičiančiu kodu?}
\subsubsection{Kaip valdyti esybių pokyčius ir versijavimą}
Sistemai egzistuojant ilgesnį laiką, jos pokyčiai pasidaro neišvengiami. Smulkūs pokyčiai nebūtinai paveikia bendrą sistemos struktūrą, tačiau
didesniems pokyčiams kartais reikia sukurti naujas klasių ar funkcionalumų versijas. Jei reikia palaikyti atgalinį
suderinamumą (angl. backward compatibility), sistemoje gali atsirasti kelios tų pačių esybių versijos.
Tokiu atveju kelios tų pačių esybių versijos sistemoje gali pridėti painumo. Ši problema dažnai sprendžiama sukuriant atskirus paketus skirtingoms
versijoms bei iškeliant bendras priklausomybes taip, kad jas galėtų pasiekti abi versijos. Taip galima išvengti kodo duplikacijos bei perteklinio
klasių skaičiaus paketuose.
\begin{figure}[H]
    \snugshade
    \dirtree{%
        .1 {/regex} .
        .2 {common} .
        .2 {pending} .
        .2 {v3} .
        .2 {v4} .
    }
    \endsnugshade
    \caption{Sistemos pavyzdys, kurioje skirtingos versijos patalpintos atskiruose sub paketuose, paliekant tik bendro naudojimo klases}
\end{figure}
Toks skirstymo būdas matomas keliose repozitorijose - Mongo duomenų bazėje\footnote{\url{https://github.com/mongodb/mongo/tree/master/src/third_party/boost/boost/regex}},
API skirtame kelionių valdymui\footnote{\url{https://github.com/mariazevedo88/travels-java-api/tree/master/src/main/java/io/github/mariazevedo88/travelsjavaapi/controller}}
 bei duomenų saugojimo įrankyje \footnote{\url{https://github.com/nocodb/nocodb/tree/c7cc1f92fd77f8b5daefceb7148aab4a69cb9b4e/packages/nocodb/src/meta/migrations}}.
Šiose repozitorijose v1, v2 pavadinti paketai saugo skirtingas esybių versijas.






Packaging microservice classes involves structuring your codebase in a way that promotes modularity, scalability, and maintainability within the microservices architecture. Here's how you can package microservice classes effectively:


2. *Separate Concerns*:
- Follow the single responsibility principle (SRP) by separating concerns within each package.
- For example, separate classes responsible for handling HTTP requests, business logic, data access, and external integrations into distinct packages or modules.


5. *API Contract Packaging*:
- Define clear API contracts for your microservices, specifying the expected inputs, outputs, and behavior of each service.
- Group classes related to API endpoints, request/response models, and error handling into dedicated packages representing the API contract.

6. *Infrastructure Concerns*:
- Separate infrastructure-related concerns, such as database access, caching, logging, and messaging, into their own packages or modules.
- This helps isolate infrastructure-specific code and configurations, making it easier to maintain and evolve over time.

code duplication


8. *Testing Concerns*:
- Organize test classes alongside production code, following a similar package structure.
- Group unit tests, integration tests, and end-to-end tests into separate packages or modules to maintain clarity and organization.

3. *Difficulty in Understanding and Navigation*:
- Unorganized code makes it hard for developers to understand the structure and relationships between different parts of the system.
- Lack of clear packaging boundaries makes navigation and code exploration challenging, especially for new team members or maintainers.


To solve the problem of multiple interface implementations, you can use several packaging techniques. Here are some approaches:

1. *Interface Segregation Principle (ISP)*:
- Follow the ISP, one of the SOLID principles, by segregating interfaces based on client requirements.
- Instead of having a single interface with multiple methods, create smaller, more focused interfaces with a single responsibility.
- Group related methods into separate interfaces, allowing classes to implement only the interfaces that are relevant to them.

2. *Package by Feature*:
- Organize classes implementing related interfaces into packages based on feature or functionality.
- Each package contains classes that provide a specific feature and implement the necessary interfaces for that feature.
- This approach keeps related classes together and reduces the likelihood of conflicts between different interface implementations.

5. *Factory Pattern*:
- Use the factory pattern to create instances of classes implementing specific interfaces.
- Define factory methods or classes that encapsulate the logic for instantiating different implementations of an interface.
- This centralizes the creation logic and allows for dynamic selection of implementations based on runtime conditions.

6. *Composition over Inheritance*:
- Prefer composition over inheritance when designing class relationships.
- Instead of implementing multiple interfaces directly in a single class, consider composing the class of multiple smaller components, each implementing a specific interface.
- This promotes flexibility, as you can mix and match components to achieve different behaviors without creating complex inheritance hierarchies.

1. *Modularity*: Packaging allows breaking down a large system into smaller, more manageable modules. This enhances modularity, making it easier to understand, maintain, and extend the codebase.



4. *Code Reusability*: Well-packaged code promotes code reuse by encapsulating reusable components or libraries into separate packages. This reduces duplication and improves overall productivity.

6. *Collaboration*: Packaging encourages collaboration among team members by providing clear boundaries between different parts of the system. It enables parallel development and reduces the risk of conflicts when multiple developers work on the same project.





Could you give patterns how to group code into packages:

Certainly! Grouping code into packages is a common practice in many programming languages to organize and manage large codebases effectively. Here are some patterns for grouping code into packages:

1. *Functional Grouping*:
- Group code based on functionality or domain. For example, in a web application, you might have packages like authentication, user-management, payment, etc.
- Each package contains related modules, classes, or functions that handle specific tasks within that domain.

2. *Layered Architecture*:
- Organize code into layers such as presentation, business logic, and data access layers.
- Each layer represents a different aspect of the application, with well-defined responsibilities and dependencies.

3. *Feature-Based Packaging*:
- Group code based on features or components of the application.
- Each feature or component has its own package containing all the necessary code, including UI, logic, and data handling.

4. *Namespace Packaging*:
- Use namespaces or packages to organize code based on hierarchical relationships.
- For example, in Java, you might have packages like com.example.project.module1, com.example.project.module2, etc.

5. *Modular Packaging*:
- Divide the application into smaller, independent modules that can be developed, tested, and deployed separately.
- Each module may contain its own set of packages, making it easier to manage dependencies and promote code reuse.

6. *Aspect-Oriented Packaging*:
- Separate cross-cutting concerns such as logging, security, and caching into their own packages.
- These packages can then be applied to different parts of the application as needed, using techniques like aspect-oriented programming (AOP).

7. *Dependency Injection Packaging*:
- Organize code based on the dependency injection (DI) hierarchy.
- Group classes and components that depend on each other closely within the same package to facilitate DI configuration and management.

8. *Component-Based Packaging*:
- Treat each component of the application as a standalone unit with its own package.
- Components may include UI widgets, services, data models, etc., each residing in its own package for easier maintenance and reuse.

By applying these packaging patterns, you can create a well-organized codebase that is easier to understand, maintain, and extend over time