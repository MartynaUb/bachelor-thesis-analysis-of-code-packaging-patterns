\section{Kodo skirstymo į paketus šablonai}
Renkantis kodo skirstymo į paketus metodą, dažniausiai rekomenduojamas skirstymas pagal dalykinės srities esybes.
Tokį skirstymą galima apibrėžti kaip paketų sudarymą iš klasių ar sąsajų, kurios tarpusavyje yra konceptualiai susijusios~\cite{Functional}.
Šis skirstymo būdas dažniausiai bent jau iš dalies naudojamas net sistemose, kurios neturi aiškiai apibrėžto skirstymo būdo.
Tačiau šis metodas negali būti vienareikšmiškai pritaikomas kiekvienoje situacijoje.
Tai lemia, kad praktikoje jo nėra griežtai laikomasi - klasės būna išskaidytos remiantis papildomomis taisyklėmis,
siekiant išspręsti sistemos planavimo metu kylančias problemas.
Norint išskirti šias papildomas taisykles, šablonus, buvo nagrinėjamos atviro kodo sistemos,
stebimi nukrypimai nuo bendresnio kodo skirstymo būdo ir identifikuojami klausimai arba problemos, kurias jais buvo bandoma išspresti.

\subsection{Sistemų analizės procesas}
Praktikoje naudojamų šablonų paieška buvo atliekama stebint atviro kodo sistemų struktūrą ir bandant nustatyti, kodėl pasirenkama nukrypti
nuo pagrindinio skirstymo būdo.
Nagrinėtos įvairių tipų sistemos - tiek taikomoji, tiek techninė programinė įranga.
Pastebėta, kad nukrypimai nuo pagrindinio skirstymo būdo dažnai pasikartodavo bandant išspręsti tas pačias problemas,
tačiau jų sprendimo būdai gali būti skirtingi.

\subsection{Problemos}
Šiame skyriuje pateikiamos analizuotose sistemose rastos problemos, kartu su jas sprendžiančiais šablonais ir pavyzdžiais,
kokiose sistemose jie yra.

\subsubsection{Pagalbinių, daugkartinio naudojimo klasių skirstymas}
Pagalbinės klasės galėtų būti apibrėžiamos kaip tiesiogiai su domeno sritimi nesusijusios, techninių funkcijų klasės,
pavyzdžiui, atsakingos už masyvų filtravimą, darbą su failais.
Pagalbinės ir daugkartinio naudojimo klasės dažniausiai negali būti patogiai grupuojamos skirstant pagal dalykinės srities esybes - pagalbines klases gali
naudoti kelios esybės, todėl neaišku, prie kurios jas reikėtų priskirti.
Vienas iš šablonų, sprendžiančių šią problemą - turėti vieną paketą, skirtą visoms pagalbinėms klasėms, kuris yra paminėtas sistemos
dokumentacijoje ir apie jo egzistavimą teoriškai žino visi komandos nariai.
Pakete galima turėti atskiras klases kiekvienai bendrinei dalykinei sričiai, iš kurios pavadinimo programuotojas galėtų nuspresti,
kad jo ieškomas funkcionalumas bus būtent toje klasėje.
\begin{figure}[H]
\snugshade
\dirtree{%
    .1 {/} .
    .2 {users} .
    .3 {UserRolesGrouping} .
    .2 {\ldots} .
    .2 {payments} .
    .3 {PaymentScheduler} .
    .2 {\ldots} .
    .2 {transactions} .
    .3 {TransactionBatching} .
    .2 {common} .
    .3 {Arrays} .
    .3 {Maps} .
    .3 {SqlQueries} .
    .3 {Users} .
}
\endsnugshade
\caption{Sistemos pavyzdys, kur visas bendrinio panaudojimo kodas guli \textit{common} pakete, pirmame sistemos paketų lygyje}
\end{figure}
Jei pagalbinių klasių dydis labai išauga, galima vietoje vienos atskiros klasės vienai bendrinei sričiai sukurti vieną paketą,
ir jame turėti kelias pagalbines klases, susijusias su ta dalykine sritimi.
\begin{figure}[H]
\snugshade
\dirtree{%
    .1 {/common} .
    .2 {arrays} .
    .3 {ArrayFilters} .
    .3 {ArrayComparators} .
    .2 {\ldots} .
    .2 {maps} .
    .3 {MapTransformations} .
    .3 {MapJoining} .
    .2 {json} .
    .3 {JsonParser} .
    .2 {\ldots} .
    .2 {database} .
    .3 {DatabaseConnection} .
    .3 {DatabaseQueries} .
}
\endsnugshade
\caption{Sistemos pavyzdys, kur bendrinio panaudojimo kodas guli \textit{common} pakete, po dalykinės srities subpaketais, taip sumažinant klasių dydį }
\end{figure}
Tokį pagalbinių klasių skirstymo metodą naudoja keletas repozitorijų - pavyzdžiui, užrašinės aplikacijos \textit{Omni-Notes}\footnote{\url{https://github.com/federicoiosue/Omni-Notes/tree/develop/omniNotes/src/main/java/it/feio/android/omninotes/utils}} bei
\textit{Fire Sticker}\footnote{\url{https://github.com/hackjutsu/Fire_Sticker/tree/master/app/src/main/java/com/gogocosmo/cosmoqiu/fire_sticker/Utils}}.
\textit{Omni-Notes} atveju, \textit{utils} pakete esančios klasės papildomai skirstomos pagal atitinkamą dalykinę sritį.
Šio šablono aprašymas -
\begin{center}
    \begin{tabular}{|p{5cm}|p{10cm}|}
        \hline
        Šablonas &  Atskiras pagalbinių klasių paketas \\ [0.5ex]
        \hline\hline
        Sprendžiama problema & Pagalbinių klasių skirstymas\\
        \hline
        Siekiamybė &  Mažesnė kodo duplikacija, lengvai randamos pagalbinės klasės \\
        \hline
        Siūlomas sprendimas & Sukurti atskirą pagalbinių klasių paketą dalykinės srities esybių lygmenyje \\
        \hline
        Galimos variacijos & Gali būti papildomai sukuriami subpaketai pagal pagalbinių klasių dengiamą funkcionalumą \\
        \hline
    \end{tabular}
\end{center}

Šiai problemai spręsti galimas ir kitoks būdas - turėti keletą pagalbinių klasių paketų, patalpintų po atitinkamu bendresniu dalykinės srities
 paketu.
Tokį skirstymo į paketus šabloną naudoja transakcijoms skirta programinė įranga \textit{Seata}\footnote{\url{https://github.com/apache/incubator-seata/tree/2.x/saga/seata-saga-engine/src/main/java/org/apache/seata/saga/engine/utils}}.
Čia pagalbinės klasės yra \textit{utils} pakete žemesniame sistemos lygmenyje, pavyzdžiui, po \textit{engine} paketu.
\begin{figure}[H]
    \snugshade
    \dirtree{%
        .1 {/engine} .
        .2 {strategy} .
        .2 {sequence} .
        .2 {\ldots} .
        .2 {utils} .
        .3 {ExceptionUtils} .
        .3 {\ldots} .
    }
    \endsnugshade
    \caption{Sistemos pavyzdys, kur bendrinio panaudojimo kodas guli \textit{utils} pakete esančiame po dalykinės srities subpaketais}
\end{figure}
Šio šablono aprašymas -
\begin{center}
    \begin{tabular}{|p{5cm}|p{10cm}|}
        \hline
        Šablonas &  Pagalbinių klasių priskyrimas dalykinės srities paketui \\ [0.5ex]
        \hline\hline
        Sprendžiama problema & Pagalbinių klasių skirstymas\\
        \hline
        Siekiamybė &  Kiekvienai esybei priskirtos pagalbinės klasės\\
        \hline
        Siūlomas sprendimas & Klases laikyti \textit{util} paketuose, žemesniame lygmenyje nei dalykinės srities esybės \\
        \hline
    \end{tabular}
\end{center}

\subsubsection{Didelis klasių skaičius pakete}
Sistemai plečiantis, neišvengiamai didėja ir klasių skaičius. Net pasirinkus tinkamą klasių skirstymo į paketus metodą
ir palaikant šią tvarką, klasių skaičius pakete gali išaugti. Tokį pavyzdį galima matyti paieškos įrankio \textit{Elasticsearch}\footnote{\url{https://github.com/elastic/elasticsearch/tree/main/server/src/main/java/org/elasticsearch/transport}}
\textit{transport} pakete. Nors klasės yra sugrupuotos pagal dalykinės srities esybę, bendras jų skaičius pakete siekia beveik devyniasdešimt.
Tokiame pakete naviguoti sunku, jis taip pat gali turėti daug priklausomybių.
Jei tokia tendencija yra būdinga visai sistemai, sistema tampa mažiau lanksti pokyčiams, kadangi net ir paprastas pakeitimas
daro įtaką reišmingai sistemos daliai, pokyčiai yra labiau linkę keisti bendrą sistemos architektūrą.
Taip pat naujos sistemos versijos išleidimo \angl{release} procesas tampa sudetingesnis, kadangi yra paveikiama daugiau klasių.
Dažnai matoma, kad susidarius šiai situacijai, nukrypstama nuo skirstymo pagal dalykinės srities esybes, pradedamos grupuoti
techninio sluoksnio klasės. Tokį skirstymą galima matyti \textit{DBeaver} duomenų bazės įrankyje \footnote{\url{https://github.com/dbeaver/dbeaver/tree/devel/plugins/org.jkiss.dbeaver.ext.mssql/src/org/jkiss/dbeaver/ext/mssql}} -
Aukštesniame lygmenyje grupuojant pagal dalykinės srities esybes, pavyzdžiui, \textit{MsSql}, vėliau pereinama prie skirstymo
pagal techninį sluoksnį pakete \textit{model}.
Šio šablono aprašymas -
\begin{center}
    \begin{tabular}{|p{5cm}|p{10cm}|}
        \hline
        Šablonas &  Žemesnio lygio paketų sudarymas grupuojant pagal techninį sluoksnį \\ [0.5ex]
        \hline\hline
        Sprendžiama problema & Didelis klasių skaičius pakete\\
        \hline
        Siekiamybė &  Išskirti dalykinės srities esybės techninius sluoksnius \\
        \hline
        Siūlomas sprendimas & Dalykinės srities esybių klases skirstyti pagal techninį sluoksnį \\
        \hline
    \end{tabular}
\end{center}

Kitą skirstymo būdą galima stebėti \textit{IntelliJ} įskiepyje \footnote{\url{https://github.com/wix-incubator/source-wizard/tree/master/src/main/kotlin/plugin}}.
Čia \textit{plugin} paketo esybė yra papildomai išskirstyta pagal \textit{IntelliJ} sistemos domeno esybes.
Vadovaujantis šiuo šablonu, klasės skirstomos pagal smulkesnį jų teikiamą funkcionalumą.
Šio šablono variacija - smulkūs moduliai su atskirose klasėse aprašytais kontraktais.
Funkcionalumas kitiems paketams galėtų būti pasiekiamas per vieną minimalią sąsają \angl{interface},
kuri atskleidžia tik konceptus (metodus arba duomenų tipus), kurie yra glaudžiai susiję su komponento teikiama paslauga, bei
klase, grąžinančią minėtos sąsajos įgyvendinimą.
Tai gali būti paprasta klasė, su statine funkcija, kurios rezultatas yra ši sąsaja, arba, esant keliomis sąsajos implementacijomis,
\textit{Static factory} dizaino šablonas, kuris nusprendžia, kurį įgyvendinimą reikėtų grąžinti pagal paduotus argumentus.
Visos kitos klasės naudoja \textit{package} pasiekiamumo modifikatorių, taip kompiliatoriaus pagalba užtikrinant,
kad jos nebus pasiektos iš išorės.
Toks principas yra sutinkamas \textit{Typescript} programavimo kalboje, kur kiekvienas modulis (šios kalbos paketo atitikmuo) turi
\textit{index.ts} failą, veikiantį kaip sąsaja, apibrėžianti, kokios modulio klasės bei funkcijos gali būti pasiekiamos už paketo ribų.
Toki šabloną naudoja turinio valdymo sistema \textit{Keystone}\footnote{\url{https://github.com/keystonejs/keystone/tree/main/packages/core/src/fields/types}},
kur kiekviena esybė turi savo modulį, atliekantį vieną funkciją, kurios kontraktas aprašytas \textit{index.ts} faile.

\begin{figure}[H]
    \snugshade
    \dirtree{%
        .1 {/types} .
        .2 {image} .
        .3 {views} .
        .3 {utils} .
        .3 {index} .
        .2 {text} .
        .3 {views} .
        .3 {index} .
        .2 {...} .
        .2 {checkbox} .
        .3 {views} .
        .3 {index} .
    }
    \endsnugshade
    \caption{\textit{Keystone} sistemos dalis, kurioje matomi smulkūs moduliai su \textit{index.ts} failuose aprašytais kontraktais}
\end{figure}

Šio šablono aprašymas -
\begin{center}
    \begin{tabular}{|p{5cm}|p{10cm}|}
        \hline
        Šablonas &  Skirstymas pagal smulkų funkcionalumą \\ [0.5ex]
        \hline\hline
        Sprendžiama problema & Didelis klasių skaičius pakete\\
        \hline
        Siekiamybė &  Maži paketai, turintys aiškiai apibrėžtą funkcionalumą\\
        \hline
        Siūlomas sprendimas & Klases suskirstyti pagal smulkesnį jų teikiamą funkcionalumą \\
        \hline
        Galimos variacijos & Smulkūs moduliai su atskirose klasėse aprašytais kontraktais \\
        \hline
    \end{tabular}
\end{center}

\subsubsection{Skirtingų sąsajų implementacijų skirstymas}
Sistemai plečiantis galima susidurti su problema, kad išauga sąsajos įgyvendinimų skaičius.
Ši problema aktuali skirstant klases pagal dalykinės srities esybes - laikant sąsajų įgyvendinimus
skirtinguose esybių paketuose (kai sąsaja nėra susijusi su viena esybe, pavyzdžiui, ją įgyvendina kelios esybės),
navigacija paketuose pasidaro sudėtinga, neaišku, kas kurią klasę įgyvendina.
Galimas šios problemos sprendimas - sukurti sąsajos implementacijas tame pačiame pakete kaip ir pati sąsaja.
Toks skirstymo į paketus šablonas yra sutinkamas \textit{Java} standartinėje bibliotekoje\footnote{\url{https://github.com/AdoptOpenJDK/openjdk-jdk11/tree/master/src/java.base/share/classes/java/util}},
kur visos standartinės sąsajos bei jų implementacijos yra tame pačiame pakete.
\begin{figure}[H]
    \snugshade
    \dirtree{%
        .1 {/util} .
        .2 {Map} .
        .2 {HashMap} .
        .2 {LinkedHashMap} .
        .2 {WeakHashMap} .
        .2 {TreeMap} .
        .2 {...} .
        .2 {List} .
        .2 {LinkedList} .
        .2 {ArrayList} .
    }
    \endsnugshade
    \caption{\textit{Java} standartinės bibliotekos pavyzdys, kuriame sąsajų įgyvendinimai guli tame pačiame pakete, kaip ir sąsajos}
\end{figure}

Šio šablono aprašymas -
\begin{center}
\begin{tabular}{|p{5cm}|p{10cm}|}
    \hline
    Šablonas & Sąsajų ir implementacijų grupavimas \\ [0.5ex]
    \hline\hline
    Sprendžiama problema & Daug skirtingų sąsajų implementacijų\\
    \hline
    Siekiamybė &  Susieti sąsają ir jos implementacijas lengvesnei jų paieškai\\
    \hline
    Siūlomas sprendimas & Sąsajų įgyvendinimus laikyti tame pačiame pakete, kaip ir sąsajas \\
    \hline
\end{tabular}
\end{center}

Kitas galimas sprendimo būdas - sąsaja, kuri turi daug skirtingų įgyvendinimų, turėtų turėti specifiškai jai sukurtą paketą, o kiekvienam paketo
įgyvendinimui sukuriama po subpaketą, kuriame yra tiek klasę įgyvendinanti sąsają, tiek kitos, įgyvendinimui reikalingos klasės.
Šablone aprašyta paketų struktūra buvo sutikta tokiose sistemose kaip \textit{HikariCP}\footnote{\url{https://github.com/brettwooldridge/HikariCP/tree/dev/src/main/java/com/zaxxer/hikari}},
skirtoje efektyviam \textit{Java} programos prisijungimui prie duomenų bazių, bei
\textit{Leaf}\footnote{\url{https://github.com/Meituan-Dianping/Leaf/tree/master/leaf-core/src/main/java/com/sankuai/inf/leaf}}, naudojamoje unikalaus identifikatoriaus generavimui.

\begin{figure}[H]
    \snugshade
    \dirtree{%
        .1 {/} .
        .2 {segment} .
        .3 {dao} .
        .3 {model} .
        .3 {SegmentIdGenImpl} .
        .2 {snowflake} .
        .3 {SnowflakeIdGenImpl} .
        .3 {SnowflakeZookeeperHolder} .
        .2 {IdGen} .
    }
    \endsnugshade
    \caption{\textit{Leaf} sistema, kur kiekvienas sąsajos įgyvendinimas yra aprašytas subpakete}
\end{figure}
Šio šablono aprašymas -
\begin{center}
    \begin{tabular}{|p{5cm}|p{10cm}|}
        \hline
        Šablonas & Įgyvendinimų atskyrimas \\ [0.5ex]
        \hline\hline
        Sprendžiama problema & Daug skirtingų sąsajų implementacijų\\
        \hline
        Siekiamybė &  Skirtingų sąsajų bei implementacijų atskyrimas\\
        \hline
        Siūlomas sprendimas & Kiekvienam paketo įgyvendinimui sukurti subpaketą, kuriame yra tiek klasę įgyvendinanti sąsaja, tiek kitos, įgyvendinimui reikalingos klasės \\
        \hline
    \end{tabular}
\end{center}

\subsubsection{Esybių pokyčių ir versijavimo valdymas}
Sistemai egzistuojant ilgesnį laiką, jos pokyčiai pasidaro neišvengiami.
Smulkūs pokyčiai nebūtinai paveikia bendrą sistemos struktūrą, tačiau
didesniems pokyčiams kartais reikia sukurti naujas klasių ar funkcionalumų versijas. Jei reikia palaikyti atgalinį
suderinamumą (angl. backward compatibility), sistemoje gali atsirasti kelios tų pačių esybių versijos.
Tokiu atveju sistemoje egzistuojančios kelios tų pačių esybių versijos gali pridėti painumo.
Ši problema gali būti sprendžiama sukuriant atskirus paketus skirtingoms
versijoms (v1, v2, v3, \ldots) bei iškeliant bendrą, abiejų esybių naudojamą kodą į paketus taip, kad jas galėtų pasiekti abi versijos.
\begin{figure}[H]
    \snugshade
    \dirtree{%
        .1 {/regex} .
        .2 {common} .
        .2 {pending} .
        .2 {v3} .
        .2 {v4} .
        .2 {...} .
    }
    \endsnugshade
    \caption{\textit{Mongo} duomenų bazės pavyzdys, kuriame skirtingos versijos patalpintos atskiruose paketuose}
\end{figure}
Toks skirstymo būdas matomas keliose repozitorijose - \textit{Mongo}\footnote{\url{https://github.com/mongodb/mongo/tree/master/src/third_party/boost/boost/regex}} duomenų bazėje,
API skirtame kelionių valdymui \textit{travels-java-api}\footnote{\url{https://github.com/mariazevedo88/travels-java-api/tree/master/src/main/java/io/github/mariazevedo88/travelsjavaapi/controller}}
 bei duomenų saugojimo įrankyje \textit{nocodb}\footnote{\url{https://github.com/nocodb/nocodb/tree/c7cc1f92fd77f8b5daefceb7148aab4a69cb9b4e/packages/nocodb/src/meta/migrations}}.
Šiose repozitorijose v1, v2 pavadinti paketai saugo skirtingas esybių versijas.
Šio šablono aprašymas -
\begin{center}
    \begin{tabular}{|p{5cm}|p{10cm}|}
        \hline
        Šablonas &  Atskirų versijų skirstymas \\ [0.5ex]
        \hline\hline
        Sprendžiama problema & Esybių pokyčių ir versijavimo valdymas\\
        \hline
        Siekiamybė &  Palaikyti skirtingas esybių versijas \\
        \hline
        Siūlomas sprendimas & Sukurti atskirus paketus skirtingoms versijoms bei iškelti bendrą, abiejų esybių naudojamą kodą į paketus \\
        \hline
    \end{tabular}
\end{center}

