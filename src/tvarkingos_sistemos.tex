\section{Kompiuterinės sistemos vertinimas}
\subsection{Teisingai įgyvendinta kompiuterinė sistema}
Norint išsiaiškinti, kokią įtaką sistemos kokybei daro skirtingos paketų skirstymo metodologijos ir kaip objektyviai pamatuoti jų įtaką, pirmiausia
reikėtų apsibrėžti, kokiais požymiais pasižymi teisingai įgyvendinta kompiuterinė sistema.
Martin Kleppmann savo knygoje \textit{Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems} išskiria šiuos pagrindinius kriterijus:
\begin{itemize}
    \item Patikimumas, reiškiantis, kad net ir klaidų (įrangos, programinių ar žmogiškųjų) atveju,
    sistema veikia stabiliai ir patikimai, paslepiant tam tikras klaidas nuo vartotojo\cite{DataIntensiveApplications}.
    \item Prižiūrimumas, reiškiantis jog skirtingų abstrakcijų pagalba sumažintas sistemos kompleksiškumas.
    Dėl to nesunku keisti esamą sistemos funkcionalumą bei pritaikyti naujiems verslo naudojimo atvejams.
    Tai supaprastina darbą inžinierių ir operacijų komandoms dirbančioms su šia sistema, taip pat leidžia prie sistemos prisidėti naujiems žmonėms, o ne
    tik jos ekspertams.
    Tai ypač aktualu atviro kodo sistemoms\cite{DataIntensiveApplications}.
    \item Plečiamumas, reiškiantis jog sistema turi strategijas, kaip išlaikyti gerą našumą užklausų
    srautui didėjant ir sistemai augant, tai atliekant su pagrįstais kompiuteriniais resursais ir
    priežiūros kaina\cite{DataIntensiveApplications}.
\end{itemize}
Yra daug skirtingų elementų, sudarančių sistemą, kuri tenkintų aukščiau paminėtus kriterijus,
pavyzdžiui, pasirinktos technologijos, aukšto lygio architektūra, dokumentacija, sistemos testavimo
procesai, jų kiekis ir pan.
Vienas iš svarbių elementų, prisidedančių prie gerai įgyvendintos sistemos dizaino yra programinio kodo dizainas, jo skaitomumas, patikimumas.
Konvencijos, kaip vadinti kodo paketus, kokias klasės jiems priskirti ir kokios paketų hierarchijos laikytis sudaro svarbią programinio kodo dizaino dalį.
Todėl, programinės įrangos kūrimo metu, laikas skirtas rasti sistemai tinkamą paketų skirstymo šabloną ir to šablono laikytis atsiperka, padarant
programinį kodą geriau suprantamu, taip prisidedant prie bendro sistemos dizaino patikimumo ir lengvesnio palaikomumo.

Straipsnyje \textit{Investigating The Effect of Software Packaging on Modular Structure Stability}, autoriai akcentuoja, kad
gerai įgyvendintos, objektiškai orientuotos sistemos turėtų vystytis be didelių pakeitimų jų architektūroje.
To siekiama todėl, nes architektūriniai pakeitimai paveikia didelę sistemos dalį ir
jų įgyvendinimo ir priežiūros kaštai yra žymiai didesni\cite{ModularStability}.
Paketų struktūra, kuri užtikrina atsietą \angl{decoupled} komunikavimą tarp paketų, enkapsuliuoja paketų vidinius elementus, neleidžiant pakeitimais
išplisti už paketų ribų yra pagrindas tvirtai sistemos architektūrai, gebančiai efektyviai plėstis, ženkliai nesikeičiant ir sutaupant programos priežiūros kaštus.

\subsection{Kodo skirstymo paketais metodų vertinimas}
Ankstesniame skyriuje buvo nagrinėjama gerai įgyvendintos paketų struktūros įtaka geram kompiuterinės sistemos dizainui,
tačiau lieka neatsakytas klausimas - kaip įvertinti metodą kodui į paketus grupuoti, kaip objektyviai užtikrinti,
jog pasirinktas sprendimas yra būtent toks, kokio reikia, ir kokia jo įtaka kompiuterinei sistemai?
Tvarkingas, aiškiai suprantamas kodas yra subjektyvi tema, priklausanti nuo komandos,
naudojamos programavimo kalbos ar programinių įrankių bei programinės sistemos dalykinės srities.
Kodo grupavimo į paketus metodai, taip, kaip ir bendros tvarkingo kodo praktikos,
gali būti labai subjektyvūs ir patogūs tik metodą formavusiam asmeniui.
Tam, kad būtų galima pagrįstai įvertinti skirtingus kodo skirstymo šablonus, pasiekiant kuo objektyvesnį,
plačiau priimtiną rezultatą, reikėtų aprašyti kriterijus, nusakančius, ko tikimasi iš paketų struktūros.

Robert C. Martin savo knygoje \textit{Agile Software Development, Principles, Patterns, and Practices} aprašo
principus, padedančius teisingai grupuoti klases į paketus.
Rodiklis, kiek kiekvienas paketas sistemoje laikosi nurodytų principų, tam tikrame paketų skirstymo šablone, gali
būti kriterijus, įvertinti to šablono kokybei ir įtakai bendram sistemos dizainui.

todo: pridėti DSM analizę, jei trūksta

\subsubsubsection{Bendro sąryšio principas}
\textit{Klasės pakete turėtų būti susietos kartu, kad turėtų tą pačią priežastį pasikeisti. Pakeitimas,
kuris paveikia paketą, paveikia visas to paketo klases ir jokių kitų paketų.}

Kaip teigia vienos atsakomybės principas \angl{Single responsibility principle }, klasė turėtų neturėti skirtingų priežasčių keistis,
šis principas taip pat teigia, kad paketas taip pat neturėtų turėti skirtingų priežasčių pasikeisti.
Principas ragina suburti visas klases, kurios gali keistis dėl tų pačių priežasčių, į vieną vietą.
Jei dvi klasės yra taip stipriai susietos, kad jos visada keičiasi kartu, tada
jos turėtų būti tame pačiame pakete.
Kai reikia išleisti pakeitimus, geriau, kad visi pakeitimai būtų viename pakete.
Tai sumažina darbo krūvį, susijusį su pakeitimu išleidimu, pakartotiniu patvirtinimu ir programinės įrangos perskirstymu,
be reikalo nevaliduojant ir leidžiant kitų, nesusijusių modulių\cite{AgileSoftwareDevelopment}.

\subsubsection{Aciklinių priklausomybių principas}
\textit{Paketo priklausomybės diagramoje neturi būti žiedinių ciklų.}

Priklausomybių ciklai sukuria neatidėliotinų problemų.
Žiedinės priklausomybės gali sukelti domino efektą, kai nedidelis lokalus vieno modulio pokytis išplinta į kitus modulius,
dėl to norit patestuoti vieną nedidelį modulį, reikia iš naujo sukompiliuoti didžiulę sistemos dalį.
Taip pat žiedinės priklausomybės lemia programos ir kompiliavimo klaidas, kadangi pasidaro labai sunku sudaryti tvarką, kaip kompiliuoti paketus.
Iš tiesų, gali nebūti teisingos tvarkos, nes žiedinės priklausomybės gali sukelti begalinę rekursiją,
kuri sukelia nemalonių problemų tokioms kalboms kaip Java, kurios skaito savo deklaracijas iš
sukompiliuotų dvejetainių failų\cite{AgileSoftwareDevelopment}.


\subsubsection{Stabilių priklausomybių principas}
\textit{Paketų priklausomybės turetų laikytis stabilumo krypties}
Sistema negali būti visiškai statiška.
Norint jai plėstis būtinas tam tikras nepastovumas.
Kai kurie paketai yra sukurti taip, kad būtų nepastovūs, iš jų tikimasi pokyčių.
Nuo paketo, kuris, manoma, yra nepastovus, neturėtų priklausyti sunkiai pakeičiami paketai,
nes priešingu atveju nepastovų paketą taip pat bus sunku pakeisti.
Programinės įrangos niuansas, kad modulis, sukurtas taip, kad jį būtų lengva pakeisti, kartais tampa sunkiai keičiamu, kažkam
 pridėjus priklausomybę nuo jo\cite{AgileSoftwareDevelopment}.


\subsubsection{Stabilių abstrakcijų principas}
\textit{Paketas turi būti tiek abstraktūs, tiek stabilūs}
Šis principas nustato ryšį tarp stabilumo ir abstraktumo.
Stabilūs paketai turėtų būti abstraktūs, todėl ir lengvai praplečiami.
Tai pat šis principas teigia, kad nestabilus paketas turi būti konkretus, nes jo nestabilumas leidžia lengvai pakeisti jo turinio kodą.
Taigi, jei paketas yra stabilus, jį taip pat turėtų sudaryti abstrakčios klasės, užtikrinant jo išplečiamumą.
Stabilūs paketai, kurie yra lengvai išplečiami, yra lankstūs pakeitimams, nedarant didelės įtakos sitemos dizainui\cite{AgileSoftwareDevelopment}.
\subsubsubsection{Abstrakcijos matavimas}
Paketo abstrakciją galima pamatuoti santykiu tarp abstrakčių klasių (arba sąsajų \angl{interface}) pakete ir bendro klasių skaičiaus:
\begin{equation}
    Abstrakcija=\frac{N_{abstrakcios}}{N_{visos}}
\end{equation}
Abstrakcijos reikšmė gali būti tarp 0 ir 1.
Nulis reiškia, kad paketas neturi jokių abstrakčių klasiu, o vienetas nurodo, kad pakete yra tik abstrakčios klasės.

Beveik visi autoriaus aprašyti principai turi aiškiai apibrėžtas metrikas, kuriomis galima pamatuoti, kaip stipriai paketas laikosi šių principų.
Būtent šios metrikos bus naudojamos įvertinti paketus, analizuojamuose šablonuose, kad suprasti šablonų kokybę.

Paketų kokybės metrikos:
\begin{itemize}
    \item \textit{Klasių skaičius} - klasių skaičiaus metrika paketui nurodo, kiek klasių (konkrečių ir abstrakčių) yra pakete.
    Ši metrika matuoja paketo dydį.
    \item \textit{Aferentinės jungtys \angl{Afferent Couplings}} - aferentinių jungčių metrika nurodo
    skaičių paketų, kurie priklauso nuo klasių, esančių pasirinktame pakete.
    Ši metrika matuoja ateinančias priklausomybes.
    \item \textit{Eferentinės jungtys \angl{Efferent Couplings}} - eferentinių jungčių metrika nurodo skaičių kitų paketų,
    nuo kuriu priklauso klasės pasirintame pakete.
    Ši metrika matuoja išeinančias priklausomybes.
    \item \textit{Nestabilumas} - nestabilumo metrika nurodo santykį tarp eferentinių jungčių ir
    visų jungčių (Aferentinės + Eferentinės) pakete.
    Ši metrika matuoja paketo atsparumą pokyčiams, kuris buvo akcentuojama stabilių priklausomybių principe.
    Reikšmės rėžiai - nuo nulio iki vieno, kur vienas nurodo visiškai stabilų paketą, o vienetas - visiškai nestabilų.
    \item \textit{Atstumas} - Atstumo metrika apibrėžiama kaip statmenas pakuotės atstumas nuo idealizuotos linijos (A + I = 1),
    kur A yra abstrakčių klasių procentas nuo bendro paketo klasių skaičiaus.
    Ši metrika yra paketo abstraktumo ir stabilumo pusiausvyros rodiklis.
    Paketas tiesiai pagrindinėje sekoje yra optimaliai subalansuotas, atsižvelgiant į jos abstraktumą ir stabilumą.
    Šios metrikos diapazonas yra nuo nulio iki vieneto, nulis nurodo paketą, kuris sutampa su pagrindine seka,
    o vienas – paketą, kuris yra kuo toliau nuo pagrindinės sekos. todo: pataisyti
    \item \textit{Žiedinės priklausomybės} - žiedinių priklausomybių metrika skaičiuoja atvejus,
    kur pasirinkto paketo išeinančios priklausomybes taip pat yra paketo ateinančios priklausomybes (tiesiogiai arba netiesiogiai).
    Ši metrika - aciklinių priklausomybių rodiklis, minėtas aciklinių priklausomybių principe.
\end{itemize}

todo: argumentuoti metriku pagristuma