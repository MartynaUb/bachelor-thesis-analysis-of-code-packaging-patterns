\section{Kompiuterinės sistemos vertinimas}

\subsection{Teisingai įgyvendinta kompiuterinė sistema}
Norint išsiaiškinti, kokią įtaką sistemos kokybei daro skirtingos paketų skirstymo metodologijos ir kaip ojektyviai tą įtaką pamatuoti, pirmiausia
reikėtų apsibrėžti kokiais požymiais pasižymi teisingai įgyvendinta kompiuterinė sistema.
Martin Kleppmann savo knygoje \textit{Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems} išskyria šiuos pagrindinius kriterijus:
\begin{itemize}
    \item Patikimumas, reiškiantis, kad net ir klaidų (įrangos, programinių ar žmogiškųjų) atveju,
    sistema veikia stabiliai ir patikimai, paslepiant tam tikras klaidas nuo vartotojo\cite{DataIntensiveApplications}.
    \item Prižiūrimumas, reiškiantis jog skirtingų abstrakcijų pagalba sumažintas sistemos kompleksiškumas.
    Dėl to nesunku keisti esamą sistemos funkcionalumą bei pritaikyti naujiems verslo naudojimo atvejams.
    Tai supaprastina darbą inžinierių ir operacijų komandoms dirbančioms su šia sistema, taip pat leidžia prie sistemos prisidėti naujiems žmonėms, o ne
    tik jos ekspertams.
    Tai ypač aktualu atviro kodo sistemoms\cite{DataIntensiveApplications}.
    \item Plečiamumas, reiškiantis jog sistema turi strategijas, kaip išlaikyti gerą našumą užklausų
    srautui didėjant ir sistemai augant, tai atliekant su pagrįstais kompiuteriniais resursais ir
    priežiūros kaina\cite{DataIntensiveApplications}.
\end{itemize}
Yra daug skirtingų elementų, sudarančių sistemą, kuri tenkintų aukščiau paminėtus kriterijus,
pavyzdžiui, pasirinktos technologijos, aukšto lygio architektūra, dokumentacija, sistemos testavimo
procesai, jų kiekis ir pan.
Vienas iš svarbių elementų, prisidedančių prie gerai įgyvendintos sistemos dizaino yra programinio kodo dizainas, jo skaitomumas, patikimumas.
Konvencijos, kaip vadinti kodo paketus, kokias klasės jiems priskirti ir kokios paketų hierarchijos laikytis sudaro svarbią programinio kodo dizaino dalį,
Todėl programinės įrangos kurimo metu, laikas skirtas rasti sistemai tinkamą paketų skirstymo šabloną ir to šablono laikymasis atsiperka, padarant
programinį kodą geriau suprantamu, taip prisidėdant prie bendro sistemos dizaino patikimumo ir lengvesnio palaikomumo.

Straipsnyje \textit{Investigating The Effect of Software Packaging on Modular Structure Stability}, jo autoriai akcentuoja, kad
gerai įgyvendintos, objektiškai orientuotos sistemos turėtų vystytis be didelių pakeitimu jų architektūroje.
To siekiama todėl, nes architektūriniai pakeitimai paveikią didelę sistemos dalį ir todėl
jų įgyvendinimo ir priežiūros kaštai yra ženkliai didesni\cite{ModularStability}.
Paketų struktūra, kuri užtikrina atsieta \angl{decoupled} komunikavima tarp paketų, enkapsuliuoja paketų vidinius elementus, neleidžiant pakeitimais
išplisti už paketų ribų yra pagrindas tvirtai sistemos architektūrai, gebančiai efektyviai plėstis, ženkliai nesikeičiant ir sutaupant programos priežiūros kaštus.

\subsection{Kodo skirstymo paketais metodų vertinimas}
Ankstesniame skyriuje buvo nagrinėjama gerai įgyvendintos paketų struktūros įtaka geram kompiuterinės sistemos dizainui,
tačiau lieka neatsakytas klausimas - kaip įvertinti metodą kodui į paketus grupuoti, kaip objektyiviai užtikrinti
jog šis sprendimas yra butent toks kokio reikia ir kokia būtent jo įtaka kompiuterinei sistemai?
Tvarkingas, aiškiai suprantamas kodas yra subjektyvi tema, priklausanti nuo komandos,
naudojamos programavimo kalbos ar programinių įrankių bei programinės sistemos dalykinės srities.
Kodo grupavimo į paketus metodai, taip, kaip ir bendros tvarkingo kodo praktikos,
gali būti labai subjektyvūs ir patogus tik metodą formavusiam asmeniui.
Tam, kad pagrįstai įvertinti skirtingus kodo skirstymo šablonus, pasiekiant kuo objektyvesnį,
plačiau priimtiną rezultatą, reikėtų aprašyti kriterijus, ko tikimasi iš paketų struktūros.

Robert C. Martin savo knygoje \textit{Agile Software Development, Principles, Patterns, and Practices} aprašo
principus padedančius teisingai grupuoti klases į paketus.
Rodiklis, kiek kiekvienas paketas sistemoje laikosi nurodytų principų, tam tikrame paketų skirstymo šablone, gali
būti kriterijus, įvertinti to šablono kokybei ir įtakai bendram sistemos dizainui.

todo: prideti DSM analize, jei truksta

\subsubsubsection{Bendro sąryšio principas}
\textit{Klasės pakete turėtų būti susietos kartu, kad turėtų tą pačią priežastį pasikeisti. Pakeitimas
kuris paveikia paketą, paveikia visas to paketo klasėms ir jokiems kitiems paketams.}

Kaip vienos atsakomybės principas \angl{Single responsibility principle } sako, kad klasė turėtų neturėti skirtingų priežasčių keistis,
šis principas teigia, kad paketas taip pat neturėtų turėti skirtingų priežasčių pasikeisti.
Principas ragina suburti visas klases, kurios gali keistis dėl tų pačių priežasčių, į vieną vietą.
Jei dvi klasės yra taip stipriai susietos, kad jos visada keičiasi kartu, tada
jos turėtų būti toje pačioje pakuotėje.
Kai reikia išleisti pakeitimus, geriau, kad visi pakeitimai būtų viename pakete.
Tai sumažina darbo krūvį, susijusį su pakeitimu išleidimu, pakartotiniu patvirtinimu ir programinės įrangos perskirstymu,
be reikalo nevaliduojant ir leidžiant kitų, nesusijusių modulių\cite{AgileSoftwareDevelopment}.

\subsubsection{Aciklinių priklausomybių principas}
\textit{Paketo priklausomybės diagramoje neturi būti žiedinių ciklų.}

Priklausomybių ciklai sukuria neatidėliotinų problemų.
Žiedinės priklausomybės gali sukelti domino efektą, kai nedidelis lokalus vieno modulio pokytis išplinta į kitus modulius,
dėl to norit patestuoti viena nedidėli modulį, reikia iš naujo sukompiliuoti didžiulę sistemos dalį.
Taip pat žiedinės priklausomybės lemia programos ir kompiliavimo klaidas, kadangi pasidaro labai sunku sudaryti tvarką, kaip kompiliuoti paketus.
Iš tiesų, gali nebūti teisingos tvarkos, nes žiedinės priklausomybės gali sukelti begalinę rekursiją,
kuri sukelia nemalonių problemų tokioms kalboms kaip Java, kurios skaito savo deklaracijas iš
sukompiliuotų dvejetainių failų\cite{AgileSoftwareDevelopment}.


\subsubsection{Stabilių priklausomybių principas}
\textit{Paketų priklausomybės turetų laikytis stabilumo krypties}
Sistema negali būti visiškai statiška.
Norint jai plėstis būtinas tam tikras nepastovumas.
Kaikurie paketai yra sukurti taip, kad būtų nepastovus, iš jų tikimasi pokyčių.
Nuo paketo, kuris yra manoma nepastovus, neturėtų priklausyti sunkiai pakeičiami paketai,
nes priešingu atveju nepastovų paketą taip pat bus sunku pakeisti.
Tai yra programinės įrangos niuansas, kad modulis, sukurtas taip, kad jį būtų lengva pakeisti, tampa sunkiai keičiamu, kažkam
kitam pridėjus priklausomybė nuo jo\cite{AgileSoftwareDevelopment}.


\subsubsection{Stabilių abstrakcijų principas}
\textit{Paketas turi būti tiek abstraktus, kiek stabilus}
Šis principas nustato ryšį tarp stabilumo ir abstraktumo.
Stabilus paketai turetų būti abstraktus, todėl ir lengvai praplečiami.
Tai pat šis principas teigia, kad nestabilus pakuotė turi būti konkreti, nes jos nestabilumas leidžia lengvai pakeisti jos turinio kodą.
Taigi, jei paketas yra stabilus, jį taip pat turėtų sudaryti abstrakčios klasės, užtikrinant jo išplėčiamumą.
Stabilus paketai, kuria yra lengvai išplečiami yra lankstūs pakeitimams, nedarant didelės įtakos sitemos dizainui\cite{AgileSoftwareDevelopment}.
\subsubsubsection{Abstrakcijos matavimas}
Paketo abstrakciją galima pamatuoti santykių tarp abstrakčių klasių (arba sąsajų \angl{interface}) pakete ir bendro klasių skaičiaus:
\begin{equation}
    Abstrakcija=\frac{N_{abstrakcios}}{N_{visos}}
\end{equation}
Abstrakcijos reikšmė gali būti tarp 0 ir 1.
Nulis reiškia kad paketas neturi jokių abstrakčių klasiu, o vienetas nurodo, kad pakete yra tik abstrakčios klasės.

Beveik visi autoriaus aprašyti principai turi aiškiai apibrėžtas metrikas, kuriomis galima pamatuoti, kaip stipriai paketas laikosi šių principų.
Būtent šios metrikos bus naudojamos įvertinti paketus, analizuojamuose šablonuose, kad suprasti šablonų kokybę.

Paketų kokybės metrikos:
\begin{itemize}
    \item \textit{Klasių skaičius} - klasių skaičiaus metrika paketui nurodo, skaičių klasių (konkrečių ir abstrakčių) pakete.
    Ši metrika matuoja paketo dydį.
    \item \textit{Aferentinės jungtys \angl{Afferent Couplings}} - aferentinių jungčių metrika nurodo
    skaičių kitų paketų, kurie priklauso nuo klasių esančių pasirinktame pakete.
    Ši metrika matuoja ateinančias priklausomybes.
    \item \textit{Eferentinės jungtys \angl{Efferent Couplings}} - eferentinių jungčių metrika nurodo skaičių kitų paketų,
    nuo kuriu priklauso klasės pasirintame pakete.
    Ši metrika matuoja išeinančias priklausomybės.
    \item \textit{Nestabilumas} - nestabilumo metrika nurodo santyki tarp eferentinių jungčių ir
    visų jungčių (Aferentinės + Eferentinės) pakete.
    Ši metrika matuoja paketo atsparumui pokyčiams, apie kurį buvo akcentuojama stabilių priklausomybių principė.
    Reikšmės rėžiai - nuo nulio iki vieno, kur vienas nurodo visiškai stabilų paketą, o vienetas visiškai nestabilų.
    \item \textit{Atstumas} - Atstumo metrika apibrėžiamas kaip statmenas pakuotės atstumas nuo idealizuotos linijos (A + I = 1),
    kur A yra abstrakčių klasių procentas nuo bendro paketo klasių skaičiaus.
    Ši metrika yra paketo abstraktumo ir stabilumo pusiausvyros rodiklis.
    Paketas tiesiai pagrindinėje sekoje yra optimaliai subalansuotas, atsižvelgiant į jos abstraktumą ir stabilumą.
    Šios metrikos diapazonas yra nuo nulio iki vieneto, o nulis nurodo paketą, kuris sutampa su pagrindine seka,
    o vienas – paketą, kuris yra kuo toliau nuo pagrindinės sekos. todo: pataisyti
    \item \textit{Žiedinės priklausomybės} - žiedinių priklausomybių metrika skaičiuoja atvejus,
    kur pasirinkto paketo išeinančios priklausomybes taip pat yra paketo ateinančios priklausomybes (tiesiogiai arba netiesiogiai).
    Ši metrika aciklinių priklausomybių rodiklis, minėtas aciklinių priklausomybių principe.
\end{itemize}